"""
Expert Agent Pool — Mixture of Models orchestration.
Each agent is a specialized expert that processes runtime blocks.
"""

from typing import Dict, Any, List
import json
import hashlib


class ExpertAgent:
    """Base class for expert agents"""
    
    def __init__(self, name: str):
        self.name = name
        self.outputs: List[Dict[str, Any]] = []

    def process(self, tick: int, runtime_block: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process tick and return output.
        Must be deterministic — same inputs produce same outputs.
        
        Args:
            tick: Current tick number
            runtime_block: Immutable runtime configuration
        
        Returns:
            JSON-serializable dict with agent output
        """
        raise NotImplementedError

    def get_history(self) -> List[Dict[str, Any]]:
        """Get all outputs generated by this agent"""
        return self.outputs.copy()


class TensorAnalysisAgent(ExpertAgent):
    """Analyzes tensor semantic embeddings from runtime blocks"""
    
    def __init__(self):
        super().__init__("tensor_analysis")

    def process(self, tick: int, runtime_block: Dict[str, Any]) -> Dict[str, Any]:
        tensor_semantic = runtime_block["tensor_semantic"]
        coords = tensor_semantic["coordinates"]
        
        # Compute tensor metrics (deterministic)
        magnitude = sum(c**2 for c in coords)**0.5
        mean_coord = sum(coords) / len(coords) if coords else 0
        
        output = {
            "agent": self.name,
            "tick": tick,
            "analysis": {
                "embedding_space": tensor_semantic["embedding_space"],
                "dimension": tensor_semantic["dimension"],
                "manifold_type": tensor_semantic["manifold_type"],
                "magnitude": magnitude,
                "mean_coordinate": mean_coord,
                "coordinate_range": [min(coords), max(coords)] if coords else [0, 0]
            }
        }
        
        self.outputs.append(output)
        return output


class ConfigValidationAgent(ExpertAgent):
    """Validates runtime configuration integrity"""
    
    def __init__(self):
        super().__init__("config_validation")

    def process(self, tick: int, runtime_block: Dict[str, Any]) -> Dict[str, Any]:
        runtime_config = runtime_block["runtime_config"]
        normalized_params = runtime_config["normalized_params"]
        
        # Compute config hash for integrity verification
        config_json = json.dumps(normalized_params, sort_keys=True)
        config_hash = hashlib.sha256(config_json.encode()).hexdigest()
        
        output = {
            "agent": self.name,
            "tick": tick,
            "validation": {
                "config_source": runtime_config["config_source"],
                "param_count": len(normalized_params),
                "config_hash": config_hash[:16],  # Truncated for readability
                "integrity_verified": True,
                "has_ipfs_cid": "ipfs_cid" in runtime_config
            }
        }
        
        self.outputs.append(output)
        return output


class StatePredictionAgent(ExpertAgent):
    """Predicts next state based on tensor embedding trajectory"""
    
    def __init__(self):
        super().__init__("state_prediction")
        self.previous_coords = None

    def process(self, tick: int, runtime_block: Dict[str, Any]) -> Dict[str, Any]:
        coords = runtime_block["tensor_semantic"]["coordinates"]
        
        # Compute delta from previous tick (if available)
        delta = None
        if self.previous_coords and len(self.previous_coords) == len(coords):
            delta = [coords[i] - self.previous_coords[i] for i in range(len(coords))]
            delta_magnitude = sum(d**2 for d in delta)**0.5
        else:
            delta_magnitude = 0.0
        
        # Simple prediction: extrapolate linear trend
        predicted_next = None
        if delta:
            predicted_next = [coords[i] + delta[i] for i in range(len(coords))]
        
        output = {
            "agent": self.name,
            "tick": tick,
            "prediction": {
                "delta_magnitude": delta_magnitude,
                "has_prediction": predicted_next is not None,
                "trajectory_stable": delta_magnitude < 0.1 if delta else True
            }
        }
        
        self.previous_coords = coords
        self.outputs.append(output)
        return output


class ExpertAgentPool:
    """
    Orchestrates mixture of expert agents.
    Executes agents in deterministic order each tick.
    """

    def __init__(self):
        self.agents: List[ExpertAgent] = []

    def initialize(self, runtime_block: Dict[str, Any]):
        """Initialize agents based on runtime block configuration"""
        # Import GT Racing agent (lazy import to avoid dependency issues)
        try:
            from gt_racing_agent import GTRacingAgent
            from ipfs_client import IPFSClient
            
            # Initialize IPFS client for Replay Court bridge
            ipfs = IPFSClient()
            gt_agent = GTRacingAgent(ipfs_client=ipfs if ipfs.is_available() else None)
            
            # Standard agents + GT Racing
            self.agents = [
                TensorAnalysisAgent(),
                ConfigValidationAgent(),
                StatePredictionAgent(),
                gt_agent
            ]
        except ImportError as e:
            # Fallback: GT Racing not available
            print(f"⚠️  GT Racing agent not available: {e}")
            self.agents = [
                TensorAnalysisAgent(),
                ConfigValidationAgent(),
                StatePredictionAgent()
            ]
        
        print(f"✓ Initialized {len(self.agents)} expert agents:")
        for agent in self.agents:
            print(f"  - {agent.name}")

    def execute_tick(
        self,
        tick: int,
        runtime_block: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Run all agents for this tick in deterministic order.
        
        Args:
            tick: Current tick number
            runtime_block: Runtime configuration
        
        Returns:
            List of agent outputs (one per agent)
        """
        outputs = []
        
        # Execute in fixed order (sorted by agent name for determinism)
        for agent in sorted(self.agents, key=lambda a: a.name):
            try:
                output = agent.process(tick, runtime_block)
                outputs.append(output)
                print(f"  ✓ {agent.name}")
            except Exception as e:
                # Log error but continue with other agents (fail-closed for agent)
                print(f"  ✗ {agent.name}: {str(e)}")
                outputs.append({
                    "agent": agent.name,
                    "tick": tick,
                    "error": str(e),
                    "status": "FAILED"
                })
        
        return outputs

    def get_agent_summaries(self) -> Dict[str, Dict[str, Any]]:
        """Get summary statistics for all agents"""
        summaries = {}
        for agent in self.agents:
            history = agent.get_history()
            summaries[agent.name] = {
                "total_outputs": len(history),
                "latest_tick": history[-1]["tick"] if history else None
            }
        return summaries
